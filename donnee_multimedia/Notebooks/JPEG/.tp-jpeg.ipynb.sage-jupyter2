{"backend_state":"init","connection_file":"/projects/e2503562-6d13-4747-916f-99fc7cd2986b/.local/share/jupyter/runtime/kernel-86db2759-a43e-48e7-abae-93c513a520d3.json","kernel":"python3-ubuntu","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"anaconda-cloud":{},"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.5"}},"trust":true,"type":"settings"}
{"cell_type":"code","exec_count":1,"id":"4d9ee4","input":"# on importe tout ce qu'il faut pour la suite du TP\nimport numpy as np\nimport random\nfrom skimage import io\nfrom skimage import transform\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom plotly.subplots import make_subplots\nfrom skimage import color\nfrom skimage import metrics\nfrom scipy import fftpack\n\n# pour que l'affichage des matrices soit facilement lisible (plus tard dans le TP)\nnp.set_printoptions(suppress=True)\nnp.set_printoptions(precision=0)\nnp.set_printoptions(threshold=1000)\n\n# une sous-figure\nfig = make_subplots(rows=2, cols=2)\n\n# on charge une image\nimage = io.imread('./chat.jpg')\n\n# on la redimensionne à un multiple de 8 pixels (ca simplifiera notre travail plus tard)\nimage = transform.resize(image,(image.shape[0]//8*8,image.shape[1]//8*8))\nfig = px.imshow(image)\nfig.update_layout( title_text=\"Image originale\", title_x=0.5)\nfig.show()\nwidth=image.shape[1]\nheight=image.shape[0]\n\n# le facteur de sous-échantillonage utilisé\ndownscale = 8\n\n# sous échantillonnage de l'image \ndownsampled=transform.resize(image,(height//downscale,width//downscale))\n\n# puis remise à l'échelle\nsubsampled0=transform.resize(downsampled,(height,width),order=0)\nsubsampled1=transform.resize(downsampled,(height,width),order=1)\nsubsampled2=transform.resize(downsampled,(height,width),order=3)\n\n# Affichage des images et mesure de qualité\nfig = px.imshow(subsampled0)\nfig.update_layout( title_text=\"Plus proche voisin\", title_x=0.5)\nfig.show()\nfig = px.imshow(subsampled1)\nfig.update_layout( title_text=\"Bilinéaire\", title_x=0.5)\nfig.show()\nfig = px.imshow(subsampled2)\nfig.update_layout( title_text=\"Bicubique\", title_x=0.5)\nfig.show()\nprint(\"PSNR après sous + sur échantillonnage global (plus proche voisin): \", metrics.peak_signal_noise_ratio(image,subsampled0))\nprint(\"PSNR après sous + sur échantillonnage global (bilinéaire): \", metrics.peak_signal_noise_ratio(image,subsampled1))\nprint(\"PSNR après sous + sur échantillonnage global (bicubique): \", metrics.peak_signal_noise_ratio(image,subsampled2))","output":{"0":{"data":{"iframe":"d1e5d6b510e1f986ee900e0aabbf92a514177fc3"},"exec_count":1,"output_type":"execute_result"},"1":{"data":{"iframe":"c5f055b827d48ebe0e2459c370a74f4a40d6429f"},"exec_count":1,"output_type":"execute_result"},"2":{"data":{"iframe":"184546ced2ae7a11a7e194041e11584b56caedd0"},"exec_count":1,"output_type":"execute_result"},"3":{"data":{"iframe":"f26ed349aa7dfa28aa58c2844b5539e4fb3aa5d6"},"exec_count":1,"output_type":"execute_result"},"4":{"name":"stdout","output_type":"stream","text":"PSNR après sous + sur échantillonnage global (plus proche voisin):  23.40569987728631\nPSNR après sous + sur échantillonnage global (bilinéaire):  23.88561120706595\nPSNR après sous + sur échantillonnage global (bicubique):  24.5606664942177\n"}},"pos":1,"type":"cell"}
{"cell_type":"code","exec_count":10,"id":"cb5b26","input":"# JPEG \"progressif\"\n\nzigzagorder = [ 1,  9,  2,  3,  10, 17, 25, 18, 11, 4,  5,  12, 19, 26, 33, 41, 34, 27, 20, 13, 6,  7,  14, 21, 28, 35, 42, 49, 57, 50, 43, 36, 29, 22, 15, 8,  16, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 24, 32, 39, 46, 53, 60, 61, 54, 47, 40, 48, 55, 62, 63, 56, 64]\n\n# on a 13 niveaux de transmission progressive\nfor level in range(1, 64, 5):\n    # On procède bloc par bloc\n    for y in range(0,height*8//8,8):\n        for x in range(0, width*8//8,8):\n            bloc=np.zeros((8,8))\n            # En ne gardant qu'une partie des données\n            for i in range(0,level):\n                yy=(zigzagorder[i]-1)//8\n                xx=(zigzagorder[i]-1)%8\n                bloc[yy,xx]=dctimg[y+yy,x+xx]\n            quantized[y:y+8,x:x+8]=np.multiply(np.round(np.divide(bloc,Q*0.1)),Q*0.1)\n            compressedimg[y:y+8,x:x+8]=fftpack.idct(fftpack.idct(quantized[y:y+8,x:x+8],norm='ortho').T,norm='ortho').T\n    \n    # si certaines valeurs dépassent les valeurs admissibles (>=0 et <1) on les tronque\n    compressedimg[compressedimg>1]=1\n    compressedimg[compressedimg<0]=0\n    \n    fig = px.imshow(compressedimg, binary_string=True)\n    fig.update_layout( title_text=\"Reconstruction après transmission de \"+ str((level+1)/64) + \"% des coefficients\", title_x=0.5)\n    fig.show()\n    \n    print(\"PSNR après transmission de \", str((level+1)/64),  \"% des coefficients : \", metrics.peak_signal_noise_ratio(greyimg,compressedimg))\n    print(\"% de coefficients nuls\", 100*(quantized == 0).sum()/greyimg.size)","output":{"0":{"data":{"iframe":"f68718d6a32d8b1a8bc11b351a18ef2eca6966da"},"exec_count":10,"output_type":"execute_result"},"1":{"name":"stdout","output_type":"stream","text":"PSNR après transmission de  0.03125 % des coefficients :  23.66421220562806\n% de coefficients nuls 98.4375\n"},"10":{"data":{"iframe":"3ba5d4a9db98369a2716f6e9236b5eea1e333c61"},"exec_count":10,"output_type":"execute_result"},"11":{"name":"stdout","output_type":"stream","text":"PSNR après transmission de  0.421875 % des coefficients :  40.05557174311662\n% de coefficients nuls 69.51257115749526\n"},"12":{"data":{"iframe":"4339de8e7c88258bed6e351fd3c9f63ee8fbfea7"},"exec_count":10,"output_type":"execute_result"},"13":{"name":"stdout","output_type":"stream","text":"PSNR après transmission de  0.5 % des coefficients :  41.08629582392375\n% de coefficients nuls 67.23819971537002\n"},"14":{"data":{"iframe":"29441cf1ecd87caecdf44f065e2bd710ffb0d56c"},"exec_count":10,"output_type":"execute_result"},"15":{"name":"stdout","output_type":"stream","text":"PSNR après transmission de  0.578125 % des coefficients :  42.77598430407916\n% de coefficients nuls 64.89830407969639\n"},"16":{"data":{"iframe":"2009e62c0d58a4e37326efb89c0da84a0b191a0b"},"exec_count":10,"output_type":"execute_result"},"17":{"name":"stdout","output_type":"stream","text":"PSNR après transmission de  0.65625 % des coefficients :  44.21643351090882\n% de coefficients nuls 63.30556214421252\n"},"18":{"data":{"iframe":"4595c79bdc0932d260382912e018c1f9c038c574"},"exec_count":10,"output_type":"execute_result"},"19":{"name":"stdout","output_type":"stream","text":"PSNR après transmission de  0.734375 % des coefficients :  44.92591235134083\n% de coefficients nuls 62.57945920303605\n"},"2":{"data":{"iframe":"61c315a98e7da7d551e8e77f139e6f5ccc1c078c"},"exec_count":10,"output_type":"execute_result"},"20":{"data":{"iframe":"b31c4ff247557d97b5d434fa02ded1f03209e6ba"},"exec_count":10,"output_type":"execute_result"},"21":{"name":"stdout","output_type":"stream","text":"PSNR après transmission de  0.8125 % des coefficients :  46.073136738152094\n% de coefficients nuls 61.69028700189753\n"},"22":{"data":{"iframe":"a088c6a7a9c5cda5d4ae8337cf851a0916a8414a"},"exec_count":10,"output_type":"execute_result"},"23":{"name":"stdout","output_type":"stream","text":"PSNR après transmission de  0.890625 % des coefficients :  46.44698516058404\n% de coefficients nuls 61.4181095825427\n"},"24":{"data":{"iframe":"fc383f2a25e0ac19f04118632742fa944de3e98c"},"exec_count":10,"output_type":"execute_result"},"25":{"name":"stdout","output_type":"stream","text":"PSNR après transmission de  0.96875 % des coefficients :  46.82686991135266\n% de coefficients nuls 61.14949003795066\n"},"3":{"name":"stdout","output_type":"stream","text":"PSNR après transmission de  0.109375 % des coefficients :  31.753511970935723\n% de coefficients nuls 90.87434772296015\n"},"4":{"data":{"iframe":"8d4d9a29a4659e2f056092e0bf819f8ac268f4c0"},"exec_count":10,"output_type":"execute_result"},"5":{"name":"stdout","output_type":"stream","text":"PSNR après transmission de  0.1875 % des coefficients :  34.318376733488776\n% de coefficients nuls 84.25017789373814\n"},"6":{"data":{"iframe":"436341645d93b39659893d5018edf2548ea3e96e"},"exec_count":10,"output_type":"execute_result"},"7":{"name":"stdout","output_type":"stream","text":"PSNR après transmission de  0.265625 % des coefficients :  36.57141051389783\n% de coefficients nuls 78.17718216318785\n"},"8":{"data":{"iframe":"7cfb05e8761667136dad7e0bba1d533b5746727d"},"exec_count":10,"output_type":"execute_result"},"9":{"name":"stdout","output_type":"stream","text":"PSNR après transmission de  0.34375 % des coefficients :  38.46741764798017\n% de coefficients nuls 73.12203510436433\n"}},"pos":25,"type":"cell"}
{"cell_type":"code","exec_count":12,"id":"75aabd","input":"# Extraction de la composante continue / fréquence nulle des coefficients DCT\ncoefscont=np.zeros((height//8, width//8))\nfor y in range(0,height*8//8,8):\n    for x in range(0, width*8//8,8):\n        coefscont[y//8,x//8] = dctimg[y,x]\n        \nfig = px.imshow(coefscont, binary_string=True)\nfig.update_layout( title_text=\"Coefficients de fréquence nulle\", title_x=0.5)\nfig.show()\nprint(\"valeur moyenne, ecart-type de la composante continue de chaque bloc: \", coefscont.mean(), coefscont.std())\n\n# calcul de la différence entre une valeur DCT et la suivante\nreshapeddc=coefscont.reshape((width*height//64,1))\ndpcmcoefs=np.zeros(width*height//64)\nfor i in range(1,width*height//64):\n    dpcmcoefs[i]=reshapeddc[i]-reshapeddc[i-1]\ncoefscont=dpcmcoefs.reshape((height//8,width//8))\n\nfig = px.imshow(coefscont, binary_string=True)\nfig.update_layout( title_text=\"Différence avec le coefficient précédent (gauche)\", title_x=0.5)\nfig.show()\nprint(\"valeur moyenne, ecart-type  de la composante continue de chaque bloc après codage DPCM: \", dpcmcoefs.mean(), dpcmcoefs.std())\n","output":{"0":{"data":{"iframe":"f60114a4c5c6dc34029628992b087c741f53961b"},"exec_count":12,"output_type":"execute_result"},"1":{"name":"stdout","output_type":"stream","text":"valeur moyenne, ecart-type de la composante continue de chaque bloc:  4.229738371035666 1.977170416873402\n"},"2":{"data":{"iframe":"123286532cd5ca5e69a182723aae771a4c9aff7b"},"exec_count":12,"output_type":"execute_result"},"3":{"name":"stdout","output_type":"stream","text":"valeur moyenne, ecart-type  de la composante continue de chaque bloc après codage DPCM:  -0.0011678966267101507 0.7491941635904122\n"}},"pos":29,"type":"cell"}
{"cell_type":"code","exec_count":13,"id":"2ef6cb","input":"# Simulation de perte de blocs lors de la transmission\ndcterror=quantized.copy()\nprobaerror=0.01\nfor y in range(0,height,8):\n    for x in range(0, width,8):\n        if random.random() <= probaerror:\n            dcterror[y:y+8,x:x+8] = 0;\n\n# On insère ici le code du correcteur d'erreurs   \n# C'est à vous de jouer !\n\n# Décodage de l'image\nfor y in range(0,height,8):\n    for x in range(0, width,8):\n        compressedimg[y:y+8,x:x+8]=fftpack.idct(fftpack.idct(dcterror[y:y+8,x:x+8],norm='ortho').T,norm='ortho').T\n\nfig = px.imshow(compressedimg, binary_string=True)\nfig.update_layout( title_text=\"Image avec blocs manquants\", title_x=0.5)\nfig.show()\nprint(\"PSNR après erreurs: \", metrics.peak_signal_noise_ratio(greyimg,compressedimg))","output":{"0":{"data":{"iframe":"e6b418ce2553c436c80329fb7b86a14ba4573367"},"exec_count":13,"output_type":"execute_result"},"1":{"name":"stdout","output_type":"stream","text":"PSNR après erreurs:  23.960755735745902\n"}},"pos":33,"type":"cell"}
{"cell_type":"code","exec_count":14,"id":"b71ce7","input":"from skimage.filters import threshold_otsu\n\ndef quantize(image, L=1, N=4):\n    T = np.linspace(0, L, N, endpoint=False)[1:]\n    return np.digitize(image.flat, T).reshape(image.shape)/(N-1)\n\n\ndef dither(image, N=4, positions=None, weights=None):\n    \"\"\"Quantize an image, using dithering.\n    Parameters\n    ----------\n    image : ndarray\n        Input image.\n    N : int\n        Number of quantization levels.\n    positions : list of (i, j) offsets\n        Position offset to which the quantization error is distributed.\n        By default, implement Sierra's \"Filter Lite\".\n    weights : list of ints\n        Weights for propagated error.\n        By default, implement Sierra's \"Filter Lite\".\n    References\n    ----------\n    http://www.efg2.com/Lab/Library/ImageProcessing/DHALF.TXT\n    \"\"\"\n    image = image.copy()\n\n    if positions is None or weights is None:\n        positions = [(0, 1), (1, -1), (1, 0)]\n        weights = [2, 1, 1]\n\n    weights = weights / np.sum(weights)\n\n    T = np.linspace(0, 1, N, endpoint=False)[1:]\n    rows, cols = image.shape\n\n    out = np.zeros_like(image, dtype=float)\n    for i in range(rows):\n        for j in range(cols):\n            # Quantize\n            out[i, j], = np.digitize([image[i, j]], T)\n\n            # Propagate quantization noise\n            d = (image[i, j] - out[i, j] / (N - 1))\n            for (ii, jj), w in zip(positions, weights):\n                ii = i + ii\n                jj = j + jj\n                if ii < rows and jj < cols:\n                    image[ii, jj] += d * w\n\n    return out/(N-1)\n\n\ndef floyd_steinberg(image, N):\n    offsets = [(0, 1), (1, -1), (1, 0), (1, 1)]\n    weights = [      7,\n               3, 5, 1]\n    return dither(image, N, offsets, weights)\n\n# Image with 255 color levels\nimg = color.rgb2gray(io.imread('chat.jpg'))\n\n# Quantize to N levels\nN = 4\nimg_quant = quantize(img, N=N)\n\nimg_dither_random = img + np.abs(np.random.normal(size=img.shape,\n                                           scale=1./(3 * N)))\nimg_dither_random = quantize(img_dither_random, L=1, N=N)\n\nimg_dither_fs = floyd_steinberg(img, N=N)\n\nfig = px.imshow(img, binary_string=True)\nfig.update_layout( title_text=\"Image source\", title_x=0.5)\nfig.show()\nfig = px.imshow(img_quant, binary_string=True)\nfig.update_layout( title_text=\"Quantification (N=%d)\" % N, title_x=0.5)\nfig.show()\nfig = px.imshow(img_dither_random, binary_string=True)\nfig.update_layout( title_text=\"Quantification: Image + Bruit\", title_x=0.5)\nfig.show()\nfig = px.imshow(img_dither_fs, binary_string=True)\nfig.update_layout( title_text=\"Floyd-Steinberg\", title_x=0.5)\nfig.show()\n\nprint(img.max(), img_quant.max())\nprint(\"PSNR quantification: \", metrics.peak_signal_noise_ratio(img,img_quant))\nprint(\"PSNR dithering: Image + Bruit: \", metrics.peak_signal_noise_ratio(img,img_dither_random))\nprint(\"PSNR Floyd-Steinberg: \", metrics.peak_signal_noise_ratio(img,img_dither_fs))","output":{"0":{"data":{"iframe":"fa0c2a896ca65894ca6fe78ec2c84e87b34ef670"},"exec_count":14,"output_type":"execute_result"},"1":{"data":{"iframe":"f290acc7df2a42cbdd41494b9b4cb6cf9601e837"},"exec_count":14,"output_type":"execute_result"},"2":{"data":{"iframe":"eb5798ecfe8cdcf691cf6638e9b15227431fa3ff"},"exec_count":14,"output_type":"execute_result"},"3":{"data":{"iframe":"eb7135c30d336569063aeb10e4f39fd125c6feb0"},"exec_count":14,"output_type":"execute_result"},"4":{"name":"stdout","output_type":"stream","text":"0.9820517647058823 1.0\nPSNR quantification:  17.843651399156645\nPSNR dithering: Image + Bruit:  16.0747649664102\nPSNR Floyd-Steinberg:  17.267354070983686\n"}},"pos":39,"type":"cell"}
{"cell_type":"code","exec_count":2,"id":"0f3aec","input":"# le facteur de sous-échantillonage utilisé\ndownscale = 8\n\n# on passe dans un espace couleur plus adapté\n# et on fait un sous-échantillonnage de la seule chrominance\nimageYUV = color.rgb2luv(image)\n\nL=imageYUV[:,:,0]\nU=imageYUV[:,:,1]\nV=imageYUV[:,:,2]\n\n# sous échantillonnage des canaux U et V\nU=transform.resize(U,(height//downscale,width//downscale))\nV=transform.resize(V,(height//downscale,width//downscale))\n# puis remise à l'échelle\nU=transform.resize(U,(height,width))\nV=transform.resize(V,(height,width))\n# On reconstitue ensuite l'image d'origine avec le canal qui a été sous-échantillonné\nsubsampled=imageYUV.copy()\nsubsampled[:,:,1] = U\nsubsampled[:,:,2] = V\nsubsampled = color.luv2rgb(subsampled)\nfig = px.imshow(subsampled)\nfig.update_layout( title_text=\"Sous échantillonnage de la chrominance\", title_x=0.5)\nfig.show()\n\nprint(\"PSNR après sous + sur échantillonnage de la chrominance: \", metrics.peak_signal_noise_ratio(image,subsampled))","output":{"0":{"data":{"iframe":"f312b1a3b698725b6edc4fd060ae55b611982ca3"},"exec_count":2,"output_type":"execute_result"},"1":{"name":"stdout","output_type":"stream","text":"PSNR après sous + sur échantillonnage de la chrominance:  38.823908561636465\n"}},"pos":5,"type":"cell"}
{"cell_type":"code","exec_count":3,"id":"e3e493","input":"from scipy import fftpack\n\n# affichons la base de fonctions de la DCT sur des blocs 8x8\nfig = make_subplots(rows=8, cols=8)\nfor i in range (0,8):\n    for j in range(0,8):\n        a=np.zeros((8,8))\n        a[i,j]=1\n        # on fait une DCT 2D avec 2 DCT 1D\n        ia=fftpack.idct(fftpack.idct(a).T).T\n        #ax[i,j].imshow(ia,cmap='gray')\n        fig.add_trace(px.imshow(ia, binary_string=True).data[0], row=1+i, col=1+j)\nfig.update_xaxes(visible=False) \nfig.update_yaxes(visible=False) \nfig.show()","output":{"0":{"data":{"iframe":"b92da274c846f6b0f4530795b00fa7c584e4fd54"},"exec_count":3,"output_type":"execute_result"}},"pos":9,"type":"cell"}
{"cell_type":"code","exec_count":4,"id":"69e89c","input":"# calcul des coefficients DCT de chaque bloc 8x8\ngreyimg=color.rgb2gray(image)\ndctimg=np.zeros(greyimg.shape)\n\nfor y in range(0,height,8):\n    for x in range(0, width,8):\n        bloc=greyimg[y:y+8,x:x+8]\n        dctimg[y:y+8,x:x+8]=fftpack.dct(fftpack.dct(bloc,norm='ortho').T,norm='ortho').T\n\nfig = px.imshow(dctimg, binary_string=True)\nfig.update_layout( title_text=\"Coefficients DCT de l'image\", title_x=0.5)\nfig.show()\n\n# on affiche également les valeurs d'un bloc 8x8\nprint(\"exemple de coefficients DCT d'un bloc 8x8\")\nx=20*8\ny=20*8\nprint((255*dctimg[y:y+8,x:x+8]).round())","output":{"0":{"data":{"iframe":"42d321bf725c981a3c1425fd773d27fbede92576"},"exec_count":4,"output_type":"execute_result"},"1":{"name":"stdout","output_type":"stream","text":"exemple de coefficients DCT d'un bloc 8x8\n[[ 685.  -23.  -28.  -11.   -0.  -13.   15.    7.]\n [-215.   59.  -19.  -22.   -7.   -0.  -23.   -7.]\n [  25.   -1.   12.   11.   12.   -6.  -17.   -7.]\n [  -8.  -17.   18.   -7.   15.   26.    5.   -2.]\n [   0.    6.   -7.    7.  -19.   -4.   -0.   -5.]\n [  -5.   -2.   -5.   12.    4.    1.   -2.    4.]\n [   9.   -5.    1.   -8.    2.   -2.    1.   -0.]\n [  -2.    3.   -4.    5.    1.    1.    1.    0.]]\n"}},"pos":13,"type":"cell"}
{"cell_type":"code","exec_count":5,"id":"8fe750","input":"# reconstruction \"parfaite\"\ncompressedimg=np.zeros(greyimg.shape)\n\nfor y in range(0,height,8):\n    for x in range(0, width,8):\n        bloc=dctimg[y:y+8,x:x+8]\n        compressedimg[y:y+8,x:x+8]=fftpack.idct(fftpack.idct(bloc,norm='ortho').T,norm='ortho').T\n\nfig = px.imshow(compressedimg, binary_string=True)\nfig.update_layout( title_text=\"Reconstruction 'parfaite\", title_x=0.5)\nfig.show()\n\nprint(\"PSNR après DCT / iDCT: \", metrics.peak_signal_noise_ratio(greyimg,compressedimg))\nprint(\"% de coefficients nuls\", 100*(dctimg == 0).sum()/greyimg.size)\n","output":{"0":{"data":{"iframe":"5ed092f76f1d4b6876b0a841efcf9f27b35f861c"},"exec_count":5,"output_type":"execute_result"},"1":{"name":"stdout","output_type":"stream","text":"PSNR après DCT / iDCT:  313.7492339396977\n% de coefficients nuls 0.0\n"}},"pos":17,"type":"cell"}
{"cell_type":"code","exec_count":6,"id":"972c61","input":"quantized=np.zeros(greyimg.shape)\n\n# matrice de quantification standard de JPEG\nQ=np.array([[16,11,10,16,24,40,51,61],\n            [12,12,14,19,26,48,60,55],\n            [14,13,16,24,40,57,69,56],\n            [14,17,22,29,51,87,80,62],\n            [18,22,37,56,68,109,103,77],\n            [24,35,55,64,81,104,113,92],\n            [49,64,78,87,103,121,120,101],\n            [72,92,95,98,112,100,103,99]])/255\n\n# On génère différentes qualités d'image (et donc taux de compression) en multipliant la matrice Q par un facteur variable\nN=(4, 1, 0.5, 0.1)\n\nfor n in N:\n    # quantification et reconstruction de l'image\n    for y in range(0,height,8):\n        for x in range(0, width,8):\n            bloc=dctimg[y:y+8,x:x+8]\n            quantized[y:y+8,x:x+8]=np.multiply(np.round(np.divide(bloc,n*Q)),n*Q)\n            compressedimg[y:y+8,x:x+8]=fftpack.idct(fftpack.idct(quantized[y:y+8,x:x+8],norm='ortho').T,norm='ortho').T\n\n    # si certaines valeurs dépassent les valeurs admissibles (>=0 et <1) on les tronque\n    compressedimg[compressedimg>1]=1\n    compressedimg[compressedimg<0]=0\n    \n    # on affiche les valeurs d'un bloc 8x8 après quantification\n    print(\"Exemple de coefficients DCT d'un bloc 8x8 après quantification n*Q avec n=\",n)\n    x=20*8\n    y=20*8\n    print((255*quantized[y:y+8,x:x+8]).round())\n    print(\"PSNR après DCT / quantification / iDCT: \", metrics.peak_signal_noise_ratio(greyimg,compressedimg))\n    print(\"% de coefficients nuls\", 100*(quantized == 0).sum()/greyimg.size)\n    \n    fig = px.imshow(compressedimg, binary_string=True)\n    fig.update_layout( title_text=\"Reconstruction après quantification n*Q avec n=\"+str(n), title_x=0.5)\n    fig.show()\n \n","output":{"0":{"name":"stdout","output_type":"stream","text":"Exemple de coefficients DCT d'un bloc 8x8 après quantification n*Q avec n= 4\n[[ 704.  -44.  -40.   -0.   -0.   -0.    0.    0.]\n [-192.   48.   -0.   -0.   -0.   -0.   -0.   -0.]\n [   0.   -0.    0.    0.    0.   -0.   -0.   -0.]\n [  -0.   -0.    0.   -0.    0.    0.    0.   -0.]\n [   0.    0.   -0.    0.   -0.   -0.   -0.   -0.]\n [  -0.   -0.   -0.    0.    0.    0.   -0.    0.]\n [   0.   -0.    0.   -0.    0.   -0.    0.   -0.]\n [  -0.    0.   -0.    0.    0.    0.    0.    0.]]\nPSNR après DCT / quantification / iDCT:  31.50017626090476\n% de coefficients nuls 94.94574240986718\n"},"1":{"data":{"iframe":"df10b4c25642ca56f7e91e2de3507eae1dabf468"},"exec_count":6,"output_type":"execute_result"},"2":{"name":"stdout","output_type":"stream","text":"Exemple de coefficients DCT d'un bloc 8x8 après quantification n*Q avec n= 1\n[[ 688.  -22.  -30.  -16.   -0.   -0.    0.    0.]\n [-216.   60.  -14.  -19.   -0.   -0.   -0.   -0.]\n [  28.   -0.   16.    0.    0.   -0.   -0.   -0.]\n [ -14.  -17.   22.   -0.    0.    0.    0.   -0.]\n [   0.    0.   -0.    0.   -0.   -0.   -0.   -0.]\n [  -0.   -0.   -0.    0.    0.    0.   -0.    0.]\n [   0.   -0.    0.   -0.    0.   -0.    0.   -0.]\n [  -0.    0.   -0.    0.    0.    0.    0.    0.]]\nPSNR après DCT / quantification / iDCT:  36.76837164235168\n% de coefficients nuls 87.03717979127134\n"},"3":{"data":{"iframe":"ab9cf813a548ac58a9fe437f67cd743b64337d30"},"exec_count":6,"output_type":"execute_result"},"4":{"name":"stdout","output_type":"stream","text":"Exemple de coefficients DCT d'un bloc 8x8 après quantification n*Q avec n= 0.5\n[[ 688.  -22.  -30.   -8.   -0.  -20.   26.    0.]\n [-216.   60.  -21.  -19.  -13.   -0.  -30.   -0.]\n [  28.   -0.    8.   12.   20.   -0.   -0.   -0.]\n [  -7.  -17.   22.   -0.   26.   44.    0.   -0.]\n [   0.   11.   -0.    0.  -34.   -0.   -0.   -0.]\n [  -0.   -0.   -0.    0.    0.    0.   -0.    0.]\n [   0.   -0.    0.   -0.    0.   -0.    0.   -0.]\n [  -0.    0.   -0.    0.    0.    0.    0.    0.]]\nPSNR après DCT / quantification / iDCT:  39.238708339695634\n% de coefficients nuls 81.08870967741936\n"},"5":{"data":{"iframe":"996ec8593f61655dfe751ecd40f63799f367fa4d"},"exec_count":6,"output_type":"execute_result"},"6":{"name":"stdout","output_type":"stream","text":"Exemple de coefficients DCT d'un bloc 8x8 après quantification n*Q avec n= 0.1\n[[ 685.  -23.  -28.  -11.   -0.  -12.   15.    6.]\n [-215.   59.  -20.  -21.   -8.   -0.  -24.   -6.]\n [  25.   -1.   11.   10.   12.   -6.  -14.   -6.]\n [  -8.  -17.   18.   -6.   15.   26.    8.   -0.]\n [   0.    7.   -7.    6.  -20.   -0.   -0.   -8.]\n [  -5.   -0.   -6.   13.    8.    0.   -0.    0.]\n [  10.   -6.    0.   -9.    0.   -0.    0.   -0.]\n [  -0.    0.   -0.    0.    0.    0.    0.    0.]]\nPSNR après DCT / quantification / iDCT:  46.88738079719065\n% de coefficients nuls 61.09879032258065\n"},"7":{"data":{"iframe":"fab6fd8b5cbf988bb3bd3a83b278129306679596"},"exec_count":6,"output_type":"execute_result"}},"pos":21,"scrolled":true,"type":"cell"}
{"cell_type":"markdown","collapsed":true,"id":"305cea","input":"**Question 6:** \n1. Commenter la matrice de quantication (contenue dans la variable Q).\n2. Observer le pourcentage de coefficients DCT nuls (en fonction de l'importance de la quantification). En quoi est-ce intéressant ?\n3. Dans JPEG, les coefficients DCT sont réordonnés avec un codage zigzag avant d'être compressés (sans perte = RLE + Huffman). Pourquoi ?\n![Mon image d'illustration](figure/zigzag.jpg)\n4. Le PSNR s'affiche pour chaque cas. Tenter d'établir une correspondance entre qualité visuelle et PSNR.\n5. Faire ce travail sur plusieurs images, en particulier commenter le résultat obtenu sur l'image maths.gif","pos":22,"type":"cell"}
{"cell_type":"markdown","collapsed":true,"id":"bc62e9","input":"**Réponse 6:**","pos":23,"type":"cell"}
{"cell_type":"markdown","collapsed":true,"id":"cbc930","input":"## Transmission progressive\n\nLe script ci-dessous montre un exemple (simplifié) de comment on pourrait transmettre les coefficients DCT de manière progressive (dans un contexte de transmission sur un réseau lent).","pos":24,"type":"cell"}
{"cell_type":"markdown","id":"0ccfe4","input":"On effectue maintenant la transformation inverse pour regénérer l'image d'origine (on ne compresse donc pour l'instant pas)","pos":16,"type":"cell"}
{"cell_type":"markdown","id":"21e04f","input":"## Correction des erreurs de transmission\n\nUn bon décodeur doit être un bon (et rapide) maquilleur d'erreur : le script ci-dessous met a zéro quelques blocs de coefficients DCT dans l'image, simulant très grossièrement des problèmes de transmission.","pos":32,"type":"cell"}
{"cell_type":"markdown","id":"25a8ee","input":"## Bonus : dithering\n\nOn a vu dans ce TP que la quantification des coefficients DCT était bien plus efficace que la quantification des valeurs des pixels (comme faite en TP d'image) pour réaliser une compression importante mais préservant la qualité de l'image.\nIl y a cependant un moyen d'améliorer la qualité de la quantification directe de la valeur des pixels : le dithering...","pos":38,"type":"cell"}
{"cell_type":"markdown","id":"316f0a","input":"**Réponse 9:**","pos":35,"type":"cell"}
{"cell_type":"markdown","id":"358dfb","input":"**Question 5:** Le PSNR obtenu correspond-il à celui que vous attendiez (théoriquement) ? Pourquoi ?","pos":18,"type":"cell"}
{"cell_type":"markdown","id":"41eb9c","input":"**Réponse 7:**","pos":27,"type":"cell"}
{"cell_type":"markdown","id":"46d5b1","input":"**Réponse 1:**","pos":3,"type":"cell"}
{"cell_type":"markdown","id":"4aae8b","input":"**Réponse bonus:**","pos":41,"type":"cell"}
{"cell_type":"markdown","id":"56e431","input":"**Question 7:** \n1. Quel est le principe de cette transmission progressive ?\n2. Testez sur différents types d'image (et en particulier maths.gif). Cette méthode est-elle adapté pour tout type de contenu ?","pos":26,"type":"cell"}
{"cell_type":"markdown","id":"5ba5d8","input":"## Encodage des coefficients DCT de fréquence nulle\n\nDans JPEG, les coefficients DCT de fréquence nulle (composante continue) subissent un codage DPCM. Le script ci-dessous devrait vous aider à comprendre pourquoi.","pos":28,"type":"cell"}
{"cell_type":"markdown","id":"70142f","input":"# TP 1 : Compression d'images JPEG\n\nCe TP de multimédia est réalisé en Python3, à l'aide de la librairie scikit-image. Les tableaux utilisés par cette librairie pour manipuler les images (ndarray) proviennent de la librairie numpy. La documentation de ces deux librairies vous sera donc bien utile.\n\n**Note:** Tous les scripts de ce TP travaillent par défaut sur une image d'exemple (un chat...), mais d'autres images sont également fournies avec le TP afin que vous puissiez évaluer les algorithmes dans diverses situations. Vous pouvez également utiliser vos propres images.\n\n## Prélude : les principes de la compression JPEG\n\nLa figure ci-dessous représente les différentes étapes réalisées lors de la compression et la décompression d'images au format JPEG. Dans ce TP, on ne verra pas en détail l'ensemble de ces opérations, mais nous allons malgré tout nous attarder sur les concepts fondamentaux de JPEG (en particulier l'utilisation de la Discrete Cosinus Transform (DCT), la quantification, ainsi que le codage des coefficients obtenus).\n\n![Mon image d'illustration](figure/jpeg-encoder.gif)\n\n## Sous-échantillonnage\n\nUne façon simple de réduire la quantité d'information que contient une image est de la sous-échantillonner (càd réduire sa taille). C'est ce que fait le script ci-dessous : on sous-échantillonne (compression), puis sur-échantillonne (décompression) une image avec différentes méthodes.","pos":0,"type":"cell"}
{"cell_type":"markdown","id":"712fad","input":"## Amélioration du décodage\n\nVous avez pu constater que lorsque le taux de compression d'une image JPEG est important on voit clairement apparaitre la transition entre les différents blocs 8x8 de l'image.\n\n**Question 10:** \n1. Comment pourrait-on améliorer l'image lors du décodage pour atténuer ces transitions ?\n2. La manière dont ce filtrage est réalisé doit-elle figurer dans la norme JPEG ?","pos":36,"type":"cell"}
{"cell_type":"markdown","id":"72fc98","input":"**Question 9:** \n1. Quelle technique pourrait on utiliser pour masquer (partiellement) ces erreurs avant de décoder l'image ?\n2. Mettez en oeuvre votre technique dans le script ci-dessus et constatez (normalement) l'amélioration du PSNR","pos":34,"type":"cell"}
{"cell_type":"markdown","id":"79d2f2","input":"**Question 4:** \n1. Quelle est la taille de l'image obtenue ? Quelle aurait été la taille de l'image si on avait utilisé une FFT ?\n2. Faites le lien entre la base de fonctions de la DCT et les coefficients obtenus pour chaque bloc 8x8.\n3. Quelle est en particulier la signification du coefficient situé dans le coin haut-gauche de chaque bloc (ne pas se fier à la valeur affichée, celle-ci dépend de la normalisation utilisée pour la DCT) ?","pos":14,"type":"cell"}
{"cell_type":"markdown","id":"7a783a","input":"**Réponse 2:** ","pos":7,"type":"cell"}
{"cell_type":"markdown","id":"7c7bff","input":"## DCT\n\nOn a vu en traitement du signal et d'image qu'il était possible de représenter une image non pas par des informations spatiales, mais par des informations fréquentielles. La tranformée de fourrier discrète (DFT ou FFT) permet de réaliser cette transformation, mais ce n'est pas la seule. La transformée en cosinus discrète (DCT) en est une autre qui a des propriétés intéressantes.\n\nNote: pour simplifier les choses on travaillera sur des images en niveau de gris, mais les principes vus dans cette section peuvent être étendus simplement en travaillant sur chacun des 3 canaux couleur de l'image (Y, Cb et Cr dans le cas de JPEG).","pos":8,"type":"cell"}
{"cell_type":"markdown","id":"929740","input":"**Question 1:** Testez différents facteurs de sous-échantillonnage (ex: 2, 4, 8). \n\n1. Pour chacun, quel est le taux de compression et le PSNR obtenu ? \n2. La qualité obtenue est elle bonne (vous trouverez quelques rappels sur le PSNR ici https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio) ?","pos":2,"type":"cell"}
{"cell_type":"markdown","id":"96004f","input":"**Question 2:** \n\n1. Tout comme dans la question 1, faire varier le facteur de sous-échantillonnage et observer la qualité d'image obtenue (visuellement et via le PSNR). Indiquez également le facteur de compression obtenu. \n2. Expliquez les résultats obtenus (en particulier, ce qui change entre RGB et YUV et quelle influence cela a sur la qualité des images). Pensez à tester l'image clown.jpg, plus colorée que les chats...","pos":6,"type":"cell"}
{"cell_type":"markdown","id":"a01137","input":"**Question bonus:**\n1. Comparez les résultats de PSNR obtenus et votre propre jugement de qualité des images. Comment expliquez vous ce résultat ?\n2. Quelle est le principe du dithering (Floyd-Steinberg) ?\n3. Ce n'est pas une question... mais il existe une autre technique proche du dithering mais utilisée par les imprimantes : le halftoning. Il n'est pas inintéressant de regarder comment elle fonctionne.","pos":40,"type":"cell"}
{"cell_type":"markdown","id":"a6d49e","input":"**Question 8:**  Observez les résultat du script afin de:\n1. Expliquer ce qu'est le codage DPCM\n2. Justifier l'intéret de ce codage pour les coefficients de fréquence nulle.","pos":30,"type":"cell"}
{"cell_type":"markdown","id":"b2a750","input":"Il est temps de compresser notre image... Pour cela nous allons effectuer une quantification des coefficients DCT afin de limiter l'ensemble des valeures possibles et ainsi faciliter la compression (sans perte cette fois ci) de ces coefficients simplifiés.","pos":20,"type":"cell"}
{"cell_type":"markdown","id":"cc91cb","input":"**Réponse 5**:","pos":19,"type":"cell"}
{"cell_type":"markdown","id":"cd922f","input":"**Question 3:** \n1. Examiner et expliquer la base de fonctions de la DCT générée par le script ci-dessus.\n2. Parmi la DCT sur des blocs 8x8 faite en JPEG et la transformée de Fourier discrète que l'on appliquerait globalement sur l'image, quelle(s) transformée(s) :\n    - Permet(tent) d'analyser la répartition de l'énergie selon les fréquences ?\n    - Fournit une information sur la localisation dans l'image de ces fréquences ?\n3. Quel autre outil permet de mieux traiter ce problème de localisation et analyse en fréquence simultanées ? Est-il utilisé dans certains formats de compression d'image ?","pos":10,"type":"cell"}
{"cell_type":"markdown","id":"ce5997","input":"**Réponse 8:**","pos":31,"type":"cell"}
{"cell_type":"markdown","id":"d351ad","input":"Le script suivant calcul les coefficients DCT de tous les blocs 8x8 qui composent notre image.","pos":12,"type":"cell"}
{"cell_type":"markdown","id":"da58f1","input":"**Réponse 3:**","pos":11,"type":"cell"}
{"cell_type":"markdown","id":"de450c","input":"Le sous-échantillonnage de toute l'image est peut être un peu excessif... Nous pouvons par contre tirer partie de certaines caractéristiques de notre système visuel pour réduire la quantité de données par sous-échantillonnage de manière moins visible. Pour cela on va utiliser un espace de couleur différent du classique RGB. On utilisera ici l'espace LUV (JPEG utilise l'espace YCrCb / YUV, assez proche mais non géré par scikit-image).","pos":4,"type":"cell"}
{"cell_type":"markdown","id":"ef2a6c","input":"**Réponse 10:**","pos":37,"type":"cell"}
{"cell_type":"markdown","id":"fbf041","input":"**Réponse 4:**","pos":15,"type":"cell"}
{"id":0,"time":1616418621067,"type":"user"}
{"last_load":1616418623848,"type":"file"}