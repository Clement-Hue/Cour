{"backend_state":"init","connection_file":"/projects/e2503562-6d13-4747-916f-99fc7cd2986b/.local/share/jupyter/runtime/kernel-82b45e3d-b0e8-44d7-9008-36d7e444d65b.json","kernel":"python3-ubuntu","kernel_error":"","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.5"}},"trust":true,"type":"settings"}
{"cell_type":"code","exec_count":0,"id":"a3e7ad","input":"","pos":18,"type":"cell"}
{"cell_type":"code","exec_count":1,"id":"9cbe99","input":"from skimage import io\nfrom skimage import metrics\nimport numpy as np\nimport plotly.express as px\n\n# pour que l'affichage des matrices soit facilement lisible (plus tard dans le TP)\nnp.set_printoptions(suppress=True)\nnp.set_printoptions(precision=0)\nnp.set_printoptions(threshold=1000)\n\n'''\nSteganographyException\n'''\nclass SteganographyException(Exception):\n    pass\n\n'''\nClass for LSB based steganography\n'''\nclass SpaceSteg():\n    def __init__(self, im):\n        self.image = im\n        self.width = im.shape[1]\n        self.height = im.shape[0]\n        self.size = self.width * self.height\n        if len(im.shape) == 2:\n            self.nbchannels = 1\n            self.image = self.image.reshape((self.height,self.width,self.nbchannels))\n        else:\n            self.nbchannels = im.shape[2]\n    \n        self.maskONEValues = [1,2,4,8,16,32,64,128]\n        #Mask used to put one ex:1->00000001, 2->00000010 .. associated with OR bitwise\n        self.maskONE = self.maskONEValues.pop(0) #Will be used to do bitwise operations\n\n        self.maskZEROValues = [254,253,251,247,239,223,191,127]\n        #Mak used to put zero ex:254->11111110, 253->11111101 .. associated with AND bitwise\n        self.maskZERO = self.maskZEROValues.pop(0)\n        \n        self.curwidth = 0 #Current width position\n        self.curheight = 0 #Current height position\n        self.curchan = 0 #Current channel position\n\n    def getImage(self):\n    # Save the image using the given filename\n        if self.nbchannels == 1:\n            return self.image.reshape((self.height, self.width))\n        else:\n            return self.image.reshape((self.height, self.width, self.nbchannels))\n\n\n    def putBinaryValue(self, bits): #Put the bits in the image\n        for c in bits:\n            val = self.image[self.curheight,self.curwidth, self.curchan]\n            if int(c) == 1:\n                val = int(val) | self.maskONE #OR with maskONE\n            else:\n                val = int(val) & self.maskZERO #AND with maskZERO\n\n            self.image[self.curheight,self.curwidth, self.curchan] = val\n            self.nextSpace() #Move \"cursor\" to the next space\n            \n    def nextSpace(self):#Move to the next slot were information can be taken or put\n        if self.curchan == self.nbchannels-1: #Next Space is the following channel\n            self.curchan = 0\n            if self.curwidth == self.width-1: #Or the first channel of the next pixel of the same line\n                self.curwidth = 0\n                if self.curheight == self.height-1:#Or the first channel of the first pixel of the next line\n                    self.curheight = 0\n                    if self.maskONE == 128: #Mask 1000000, so the last mask\n                        raise SteganographyException(\"Image filled\")\n                    else: #Or instead of using the first bit start using the second and so on..\n                        self.maskONE = self.maskONEValues.pop(0)\n                        self.maskZERO = self.maskZEROValues.pop(0)\n                else:\n                    self.curheight +=1\n            else:\n                self.curwidth +=1\n        else:\n            self.curchan +=1  \n\n    def readBit(self): #Read a single bit int the image\n        val = self.image[self.curheight,self.curwidth, self.curchan]\n        val = int(val) & self.maskONE\n        self.nextSpace()\n        if val > 0:\n            return \"1\"\n        else:\n            return \"0\"\n\n    def readByte(self):\n        return self.readBits(8)\n\n    def readBits(self, nb): #Read the given number of bits\n        bits = \"\"\n        for i in range(nb):\n            bits += self.readBit()\n        return bits\n\n    def byteValue(self, val):\n        return self.binValue(val, 8)\n\n    def binValue(self, val, bitsize): #Return the binary value of an int as a byte\n        binval = bin(val)[2:]\n        if len(binval) > bitsize:\n            raise SteganographyException(\"binary value larger than the expected size\")\n        while len(binval) < bitsize:\n            binval = \"0\"+binval\n        return binval\n\n    def hideBin(self, filename):\n        f = open(filename,'rb')\n        bin = f.read()\n        l = len(bin)\n        print(\"Taille du secret (nb d'octets) :\", l)\n        if self.width*self.height*self.nbchannels < l+64:\n            raise SteganographyException(\"Carrier image not big enough to hold all the datas to steganography\")\n        self.putBinaryValue(self.binValue(l, 64))\n        for byte in bin:\n            self.putBinaryValue(self.byteValue(byte))\n\n    def unhideBin(self):\n        l = int(self.readBits(64),2)\n        output = \"\"\n        for i in range(l):\n            output += chr(int(self.readByte(),2))\n        return output\n\n\n    \n'''    \nProgramme principal\n'''\nsourceimage = \"lena.jpg\"\nsecretfile = \"secret-nano.txt\"\n\n# Insertion du secret dans l'image\ncarrier = io.imread(sourceimage)\nfig = px.imshow(carrier, binary_string=True)\nfig.update_layout( title_text=\"Image originale\", title_x=0.5)\nfig.show()\n\nsteg = SpaceSteg(carrier)\nsteg.hideBin(secretfile)\nhidden = steg.getImage()\nfig = px.imshow(hidden, binary_string=True)\nfig.update_layout( title_text=\"Image stéganographiée\", title_x=0.5)\nfig.show()\n\n# Quelques infos supplémentaires\ncarrier = io.imread(sourceimage)\ndiff = abs(carrier.astype(int)-hidden.astype(int))\nfig = px.imshow(diff, binary_string=True)\nfig.update_layout( title_text=\"Valeur absolue des différences entre les images\", title_x=0.5)\nfig.show()\nprint(\"Taille de l'image (nb d'octets) :\", carrier.size)\nnp.set_printoptions(formatter={'int':lambda x:\"{0:b}\".format(int(x))})\nprint(\"64 premiers octets (originale): \",carrier[0,0:64].astype(int))\nprint(\"64 premiers octets (steganographiée): \",hidden[0,0:64].astype(int))\nnp.set_printoptions(formatter=None)\nprint(\"Difference dans les 64 premiers octets : \",carrier[0,0:64].astype(int)-hidden[0,0:64].astype(int))\nprint(\"Difference après l'octet 64 (1ere ligne) : \",carrier[0,64:].astype(int)-hidden[0,64:].astype(int))\nprint(\"Différence max : \",diff.max())\nprint(\"PSNR : \",metrics.peak_signal_noise_ratio(carrier,hidden))\n\n# Récupération du secret\nsteg = SpaceSteg(hidden)\nbinsecret = steg.unhideBin()\nif len(binsecret) > 256:\n    print(\"Secret : \", binsecret[0:256], \"[...]\") # on affiche seulement le début du secret\nelse:\n    print(\"Secret : \", binsecret)\n    \n","output":{"0":{"data":{"iframe":"bfacf1f747d97038c5b610ecccbe8fbefee8e547"},"exec_count":1,"output_type":"execute_result"},"1":{"name":"stdout","output_type":"stream","text":"Taille du secret (nb d'octets) : 3\n"},"2":{"data":{"iframe":"3083d78c3cb1ddb246cf17a3e8f4fc0202efd08e"},"exec_count":1,"output_type":"execute_result"},"3":{"data":{"iframe":"4b2b47debfa38c4bf3466a941f4c0d3d6bc88adb"},"exec_count":1,"output_type":"execute_result"},"4":{"name":"stdout","output_type":"stream","text":"Taille de l'image (nb d'octets) : 262144\n64 premiers octets (originale):  [1111011 10011011 10101010 10101110 10101101 10101011 10100101 10001010\n 1110111 1110100 1101101 1110010 1110001 1101011 1110101 1101100 1110110\n 1110011 1111011 1111001 1111000 1111101 1110100 1111001 1111000 1110111\n 1111110 1111010 1111000 1111001 1110100 1111101 1101111 1110000 1110110\n 1110111 1110111 1110110 1111101 1111011 1111000 1110110 1111011 1110111\n 1110001 1111110 1110101 1110101 1111000 1110010 1110100 1110110 1110010\n 1110110 1110101 1110101 1110001 1110011 1110100 1110011 1111011 1110110\n 1110101 1110101]\n64 premiers octets (steganographiée):  [1111010 10011010 10101010 10101110 10101100 10101010 10100100 10001010\n 1110110 1110100 1101100 1110010 1110000 1101010 1110100 1101100 1110110\n 1110010 1111010 1111000 1111000 1111100 1110100 1111000 1111000 1110110\n 1111110 1111010 1111000 1111000 1110100 1111100 1101110 1110000 1110110\n 1110110 1110110 1110110 1111100 1111010 1111000 1110110 1111010 1110110\n 1110000 1111110 1110100 1110100 1111000 1110010 1110100 1110110 1110010\n 1110110 1110100 1110100 1110000 1110010 1110100 1110010 1111010 1110110\n 1110101 1110101]\nDifference dans les 64 premiers octets :  [1 1 0 0 1 1 1 0 1 0 1 0 1 1 1 0 0 1 1 1 0 1 0 1 0 1 0 0 0 1 0 1 1 0 0 1 1\n 0 1 1 0 0 1 1 1 0 1 1 0 0 0 0 0 0 1 1 1 1 0 1 1 0 0 0]\nDifference après l'octet 64 (1ere ligne) :  [ 0  0 -1  0  1  1  1  0  1  0  0  0  0  0  0  1  0 -1 -1  0  1  0  0  0\n  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0\n  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0]\nDifférence max :  1\nPSNR :  85.98151827239985\nSecret :  abc\n"}},"pos":1,"type":"cell"}
{"cell_type":"code","exec_count":2,"id":"641b58","input":"from skimage import transform\n\nratio=0.95\n# ici on fait un changement d'échelle, mais vous devez tester d'autre transformations (rotation, flou, sauvegarde en JPEG, etc.)\nsmaller = transform.resize(hidden, ( int(carrier.shape[0]*ratio), int(carrier.shape[1]*ratio)))\nsteg = SpaceSteg(smaller)\nbinsecret = steg.unhideBin()\nprint(binsecret) # si rien ne s'affiche, alors on a perdu le secret...","output":{"0":{"name":"stdout","output_type":"stream","text":"\n"}},"pos":9,"type":"cell"}
{"cell_type":"code","exec_count":3,"id":"976fe0","input":"from skimage import transform\nfrom skimage import color\nimport numpy as np\nfrom scipy import fftpack\n\nsourceimage = \"lena.jpg\"\nsecretfile = \"secret.txt\"\n\n#Au cas ou\n#zigzagorder = [ 1,  9,  2,  3,  10, 17, 25, 18, 11, 4,  5,  12, 19, 26, 33, 41, 34, 27, 20, 13, 6,  7,  14, 21, 28, 35, 42, 49, 57, 50, 43, 36, 29, 22, 15, 8,  16, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 24, 32, 39, 46, 53, 60, 61, 54, 47, 40, 48, 55, 62, 63, 56, 64]\n\n# lecture de l'image source\nimage = io.imread(sourceimage)\n\n# on la redimensionne à un multiple de 8 pixels\nimage = transform.resize(image,(image.shape[0]//8*8,image.shape[1]//8*8))\nwidth=image.shape[1]\nheight=image.shape[0]\n\n# calcul des coefficients DCT de chaque bloc 8x8\ngreyimg=color.rgb2gray(image)\ndctimg=np.zeros(greyimg.shape)\n\nfor y in range(0,height,8):\n    for x in range(0, width,8):\n        bloc=greyimg[y:y+8,x:x+8]\n        dctimg[y:y+8,x:x+8]=128+(32*fftpack.dct(fftpack.dct(bloc,norm='ortho').T,norm='ortho').T).astype(int)\n        dctimg[y,x] = (dctimg[y,x]-128)\n\n# Stéganographie       \nprint(\"Coefficents du 1er bloc de l'image (originale):\",dctimg[0:8,0:8])\nsteg = SpaceSteg(dctimg)\nsteg.hideBin(secretfile)\nprint(\"Coefficents du 1er bloc de l'image (stéganographiée):\",dctimg[0:8,0:8])\n\n# reconstruction (on décompresse)\ncompressedimg=np.zeros(greyimg.shape)\n\nfor y in range(0,height,8):\n    for x in range(0, width,8):\n        bloc=dctimg[y:y+8,x:x+8]-128\n        bloc[0,0] = (bloc[0,0]+128)\n        compressedimg[y:y+8,x:x+8]=fftpack.idct(fftpack.idct(bloc/32,norm='ortho').T,norm='ortho').T\n\nfig = px.imshow(compressedimg, binary_string=True)\nfig.update_layout( title_text=\"Reconstruction\", title_x=0.5)\nfig.show()\n\n# on extrait le secret\nsteg = SpaceSteg(dctimg)\nbinsecret = steg.unhideBin()\nif len(binsecret) > 256:\n    print(\"Secret : \", binsecret[0:256], \"[...]\") # on affiche seulement le début du secret\nelse:\n    print(\"Secret : \", binsecret)\n\n","output":{"0":{"name":"stderr","output_type":"stream","text":"<ipython-input-3-92a6c6d0ad5c>:21: FutureWarning:\n\nThe behavior of rgb2gray will change in scikit-image 0.19. Currently, rgb2gray allows 2D grayscale image to be passed as inputs and leaves them unmodified as outputs. Starting from version 0.19, 2D arrays will be treated as 1D images with 3 channels.\n\n"},"1":{"name":"stdout","output_type":"stream","text":"Coefficents du 1er bloc de l'image (originale): [[133. 116. 117. 127. 124. 128. 127. 128.]\n [158. 137. 123. 128. 126. 128. 128. 128.]\n [110. 124. 132. 128. 129. 128. 128. 128.]\n [134. 127. 126. 128. 128. 128. 128. 128.]\n [128. 131. 129. 128. 128. 128. 128. 128.]\n [127. 127. 128. 129. 128. 128. 128. 128.]\n [127. 128. 128. 128. 128. 128. 128. 128.]\n [129. 128. 128. 128. 128. 128. 128. 128.]]\nTaille du secret (nb d'octets) : 29364\n"},"2":{"name":"stdout","output_type":"stream","text":"Coefficents du 1er bloc de l'image (stéganographiée): [[132. 116. 116. 126. 124. 128. 126. 128.]\n [158. 136. 123. 128. 126. 128. 128. 128.]\n [110. 125. 133. 128. 128. 129. 128. 129.]\n [134. 126. 127. 128. 128. 128. 128. 128.]\n [128. 131. 129. 128. 128. 128. 129. 129.]\n [126. 127. 129. 128. 128. 129. 128. 129.]\n [126. 129. 129. 128. 129. 128. 128. 129.]\n [128. 128. 129. 128. 128. 128. 128. 128.]]\n"},"3":{"data":{"iframe":"6153a5d34d8315639408c2fcfc0dd0a33aeb4b7e"},"exec_count":3,"output_type":"execute_result"},"4":{"name":"stdout","output_type":"stream","text":"Secret :  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus feugiat massa ut dolor tincidunt vestibulum. Aenean vehicula pulvinar est, non consectetur mi. Sed sagittis eu sem in consequat. Aliquam erat volutpat. Proin posuere dui nec auctor congue.  [...]\n"}},"pos":12,"type":"cell"}
{"cell_type":"code","exec_count":4,"id":"45ab11","input":"# Insérer ici le code modifié pour la question bonus","pos":16,"type":"cell"}
{"cell_type":"markdown","collapsed":true,"id":"0c84ea","input":"**Question 5:** Testez l'algorithme avec différentes taille de secret.\n1. La qualité obtenue après DCT -> steganographie -> inverse DCT est-elle satisfaisante ? Expliquez\n2. Que devrait on faire pour que le tatouage soit plus discret ?\n3. Est-ce que la capacité de stockage (d'un secret) de l'algorithme sera différente ? Expliquez\n4. A votre avis, ce tatouage dans le domaine fréquentiel est il plus robuste aux différentes transformations? Expliquez et testez si-possible.","pos":13,"type":"cell"}
{"cell_type":"markdown","id":"05a48a","input":"**Réponse 3:** ","pos":7,"type":"cell"}
{"cell_type":"markdown","id":"3d7874","input":"**Question 1:** Testez l'algorithme avec \"secret-nano.txt\", \"secret-mini.txt\", \"secret.txt\" et \"secret-maxi.txt\". A l'aide des résultats affichés (et en regardant le code si besoin), expliquez comment fonctionne l'algorithme.","pos":2,"type":"cell"}
{"cell_type":"markdown","id":"746df4","input":"**Question 2:** En variant la taille du secret et en regardant les valeurs de PSNR obtenues (ainsi que votre propre jugement), déterminer la capacité maximum de cet algorithme permettant de garder une qualité d'image acceptable.","pos":4,"type":"cell"}
{"cell_type":"markdown","id":"7b41b4","input":"# TP 4 : Stéganographie\n\nCe TP de multimédia est réalisé en Python3, à l'aide de la librairie scikit-image. Les tableaux utilisés par cette librairie pour manipuler les images (ndarray) proviennent de la librairie numpy. La documentation de ces deux librairies vous sera donc bien utile.\n\n**Note:** Tous les scripts de ce TP travaillent par défaut sur une image d'example (Lenna), mais vous pouvez test avec d'autres images afin de teser les algorithmes dans diverses situations.\n\n\n## Stéganographie ?\n\nLa stéganographie ou tatouage d'images est un ensemble de techniques permettant de cacher des informations dans une image (le secret). Dans ce TP on va cacher du texte et des images dans des images. Mais il est bien entendu possible de cacher toute donnée binaire.\n\n\n## Stéganographie dans le domaine spatial\n\nPour cette première partie on va s'intéresser à une technique simple de stéganographie opérant directement sur les valeur des pixels. Le script ci-dessous fournit une implémentation simple de cette technique.","pos":0,"type":"cell"}
{"cell_type":"markdown","id":"9394a8","input":"**Réponse 1:** ","pos":3,"type":"cell"}
{"cell_type":"markdown","id":"a9b980","input":"**Réponse 2:**","pos":5,"type":"cell"}
{"cell_type":"markdown","id":"af79d7","input":"**Réponse 5**:","pos":14,"type":"cell"}
{"cell_type":"markdown","id":"b63a1f","input":"## Stéganographie dans le domaine fréquentiel\n\nNous allons maintenant tenter d'appliquer (naivement) la même technique que précédemment, mais aux coefficients DCT qu'on pourrait obtenir en compressant une image au format JPEG (comme dans le TP du même nom).","pos":11,"type":"cell"}
{"cell_type":"markdown","id":"b956bb","input":"*Crédits : une partie du code source de ce TP est inspiré du code suivant : https://github.com/RobinDavid/LSB-Steganography*","pos":17,"type":"cell"}
{"cell_type":"markdown","id":"be5220","input":"**Réponse 4:**","pos":10,"type":"cell"}
{"cell_type":"markdown","id":"cc8e7c","input":"**Question bonus:** Modifiez la fonction `nextSpace` et / ou le script ci-dessus afin de rendre le tatouage dans le domaine fréquentiel plus discret.","pos":15,"type":"cell"}
{"cell_type":"markdown","id":"d0e2e8","input":"**Question 3:** D'après votre compréhension de l'algorithme utilisé:\n1. Est-il facile de détecter qu'une image a été stéganographiée ? Expliquez.\n2. Si cela est possible peut on facilement récupérer les informations cachées dans l'image ? Expliquez.\n3. Comment pourrait on améliorer la confidentialité des données cachées ?","pos":6,"type":"cell"}
{"cell_type":"markdown","id":"d7f710","input":"**Question 4:** Testez quelques transformations simples sur l'image stéganographiée. \n1. Cette algorithme est il robuste aux transformations ?\n2. Y a-t-il un moyen simple d'améliorer les choses ?","pos":8,"type":"cell"}
{"id":0,"time":1617266885474,"type":"user"}
{"last_load":1616948152938,"type":"file"}